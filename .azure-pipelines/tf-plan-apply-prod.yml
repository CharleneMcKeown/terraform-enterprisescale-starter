# Azure DevOps Pipeline to perform a terraform init, terraform plan and terraform apply.
# Pipeline will trigger when a pull request is made into DEV. Stage 1 will perform terraform validation, init and plan.
# A comment will be made on the PR with Terraform changes.
# On PR approval, the pipeline will run again and in addition, will run Stage 2 Apply and apply changes to DEV.

trigger:
  branches:
    include: # Pipeline will only trigger for dev branch
    - prod
  paths:
    exclude: # This pipeline will not trigger for changes to below files and folders 
    - .azure-pipelines/*
    - '*.md'

variables:
  ARM_USE_MSI: 1
  azureSubscription: azure-sub-mgmt
  environment: prod
  keyvaultName: '' # Key Vault containing Azure DevOps PAT and Azure Resource Manager secrets
  TF_IN_AUTOMATION: 1

stages:      
  # This stage contains the necessary steps to validate and initialise Terraform
  - stage: plan 
    displayName: Terraform plan
    jobs:
    - job: tfplanjob
      displayName: Terraform plan job
      pool: terraform
      steps:  

      # This step ensures that either the pipeline is running due to a PR from main into prod, or due to individual CI
      # for prod. This step will error if any other branch is pr’d into prod.
      - script: |
          echo "PR validation builds must run from main branch. Manual or CI builds must run from prod branch."
          exit 1
        condition: |
          not(
            or(
              eq(variables['System.PullRequest.SourceBranch'], 'refs/heads/main'),
              and(
                in(variables['Build.Reason'], 'IndividualCI', 'BatchedCI', 'Manual'),
                eq(variables['Build.SourceBranchName'],'prod')
              )
            )
          )
        displayName: Check if PR from main or CI for dev

      # Checkout the repo
      - checkout: self
        persistCredentials: true
      - script: mkdir $(Build.ArtifactStagingDirectory)/tfroot
        displayName: "Create 'tfroot' directory"

      # Copy Terraform files to a new directory
      - task: CopyFiles@2
        inputs:
          SourceFolder: $(Agent.BuildDirectory)/s/
          TargetFolder: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
          Contents: |
            **/*
            !.git/**/*
        displayName: Copy files to staging directory (excluding .git)

      # Download all secrets from Key Vault
      - task: AzureKeyVault@1
        displayName: Download Secrets
        inputs:
          azureSubscription: $(azureSubscription)
          KeyVaultName: $(keyvaultName)
          SecretsFilter: '*'
          RunAsPreJob: false

      # Insert Azure DevOps PAT token into Terraform module references so they can be downloaded
      - task: CmdLine@2
        displayName: Replace Tokens
        inputs:
          script: |
            sed -i s/PATTOKEN1/$(azdopat)/ *.tf
          workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>

      # Preserve the environment specific .tf files, e.g. if canary delete .prod.tf files and visa-versa
      - script: |
          if [ "$ENVIRONMENT" == "prod" ]; then
            rm -vf *.canary.tf
          fi
          if [ "$ENVIRONMENT" == "canary" ]; then
            rm -vf *.prod.tf
          fi
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
        displayName: Remove .tf files for other environment

      # Initialise Terraform, referencing the appropriate backend file
      - script: |
          terraform init -no-color -input=false -backend-config=backend-$(environment).hcl
        displayName: Terraform init
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
        env:
          ARM_CLIENT_ID: $(arm-client-id)
          ARM_CLIENT_SECRET: $(arm-client-secret)
          ARM_SUBSCRIPTION_ID: $(arm-subscription-id)

      # Check that the Terraform configuration is syntactically valid
      - script: terraform validate
        displayName: Terraform validate
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>

      # Rewrite Terraform configuration files to a canonical format
      - script: terraform fmt -check -recursive
        displayName: Terraform fmt check
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>

      # Perform linting on Terraform files (Azure tflint config is baked into container image)
      - script: tflint
        displayName: TFlint
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>

      # Run Terraform plan with the appropriate env vars and output the plan to a file called ‘tfplan’
      # Run Terraform show on the plan to generate a JSON of the plan
      - script: | 
          terraform plan -no-color -input=false -out='tfplan' -var-file='variables-$(environment).tfvars' -detailed-exitcode
          echo "##vso[task.setvariable variable=planCode;isOutput=true]$?"
          terraform show -json tfplan > tfplan.json
          echo "##vso[task.setvariable variable=jsonPlanFilePath;isOutput=true]$(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>/tfplan.json"
        displayName: Terraform plan
        name: plan
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
        env:
          ARM_CLIENT_ID: $(ARMCLIENTID)
          ARM_CLIENT_SECRET: $(ARMCLIENTSECRET)
          ARM_SUBSCRIPTION_ID: $(ARMSUBSCRIPTIONID)
          TF_VAR_peering_client_secret: $(peering-client-secret)
          TF_VAR_peering_client_id: $(peering-client-id)
        continueOnError: true # required due to -detailed-exitcode

      # If there are Terraform errors, quit the pipeline
      - script: |
          echo "Terraform plan exit code was '1' - review previous step"
          exit 1
        displayName: Quit if plan error
        condition: and(always(), eq(variables['plan.planCode'], '1'))

      # Publish the tfplan and Terraform config for the apply stage
      - task: PublishPipelineArtifact@1
        inputs:
          targetPath: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
          ArtifactName: tfplan
        displayName: Publish plan
        condition: and(always(), eq(variables['plan.planCode'], '2'))

      # If this pipeline is running due to a PR, comment on the PR with planned Terraform changes
      - task: PowerShell@2
        displayName: 'Comment PR with Terraform Plan'
        condition: |
          and(
            succeeded(),
            eq(variables['Build.Reason'], 'PullRequest'),
            eq(variables['plan.planCode'], '2')
          )
        enabled: true
        inputs:
          filePath: '$(Agent.BuildDirectory)/s/scripts/TerraformAnnotate.ps1'
          arguments: '-JsonPlanPath $(plan.jsonPlanFilePath)'
          workingDirectory: '$(Agent.BuildDirectory)/s/scripts'
        env:
          SYSTEM_ACCESSTOKEN: $(System.AccessToken)

  # This stage will run and apply Terraform changes if the pipeline is running after a PR merge   
  - stage: apply
    displayName: Terraform apply
    dependsOn: plan
    condition: |
      and(
        succeeded(),
        in(variables['Build.Reason'], 'IndividualCI', 'BatchedCI', 'Manual')
      )
    jobs:
    - job: tfapplyjob
      displayName: Terraform apply job
      condition: | # Only run if planCode == 2 (valid plan and changes required)
        eq(stageDependencies.plan.planjob.outputs['plan.planCode'], '2')
      pool: terraform
      steps:  
      - checkout: self

      - task: CopyFiles@2
        inputs:
          SourceFolder: $(Agent.BuildDirectory)/s/
          TargetFolder: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
          Contents: |
            **/*
            !.git/**/*
        displayName: Copy files to staging directory (excluding .git)

      - task: AzureKeyVault@1
        inputs:
          azureSubscription: 
          keyVaultName: $(keyVaultName)
          secretsFilter: '*'
          runAsPreJob: false

      - task: DownloadPipelineArtifact@2
        inputs:
          targetPath: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
          ArtifactName: tfplan
        displayName: Download plan
      - script: find . -not -iname *.json -type f | xargs chmod ug+x
        displayName: Set exec bit on plugins
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>/.terraform/plugins

      # Applies terraform plan ‘tfplan’ from previous step
      - script: terraform apply -no-color -input=false 'tfplan'
        displayName: Terraform apply
        workingDirectory: $(Build.ArtifactStagingDirectory)/tfroot/<AzureDevOpsProjectName>
        env:
          ARM_CLIENT_ID: $(ARMCLIENTID)
          ARM_CLIENT_SECRET: $(ARMCLIENTSECRET)
          ARM_SUBSCRIPTION_ID: $(ARMSUBSCRIPTIONID)
          TF_VAR_peering_client_secret: $(peering-client-secret)
          TF_VAR_peering_client_id: $(peering-client-id)

    - job: openprjob
      displayName: Open PR
      dependsOn: tfapplyjob # Runs after apply, even if apply is skipped due to no changes (see condition below)
      condition: in(dependencies.tfapplyjob.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
      pool: terraform
      steps:

      # Create a Pull Request into prod
      - script: |
          az extension add --name azure-devops
          az repos pr create \
            --auto-complete false \
            --delete-source-branch false \
            --repository $(Build.Repository.Name) \
            --title "$(Build.SourceVersionMessage)" \
            --squash false \
            --source-branch $(Build.SourceBranchName) \
            --target-branch prod
        displayName: Create PR
        continueOnError: true # required if PR exists already
        env:
          AZURE_DEVOPS_EXT_PAT: $(System.AccessToken)
